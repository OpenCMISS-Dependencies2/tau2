/****************************************************************************
**			TAU Portable Profiling Package			   **
**			http://www.cs.uoregon.edu/research/tau	           **
*****************************************************************************
**    Copyright 1997  						   	   **
**    Department of Computer and Information Science, University of Oregon **
**    Advanced Computing Laboratory, Los Alamos National Laboratory        **
****************************************************************************/
/***************************************************************************
**	File 		: MPCThreadLayer.cpp				  **
**	Description 	: TAU Profiling Package RTS Layer definitions     **
**			  for supporting pthreads 			  **
**	Contact		: tau-team@cs.uoregon.edu 		 	  **
**	Documentation	: See http://www.cs.uoregon.edu/research/tau      **
***************************************************************************/


#include <mpc.h>

extern __thread void *tls_args;

//////////////////////////////////////////////////////////////////////
// Include Files 
//////////////////////////////////////////////////////////////////////

//#define DEBUG_PROF
#ifdef TAU_DOT_H_LESS_HEADERS
#include <iostream>
using namespace std;
#else /* TAU_DOT_H_LESS_HEADERS */
#include <iostream.h>
#endif /* TAU_DOT_H_LESS_HEADERS */
#include "Profile/Profiler.h"

#include <stdlib.h>

#ifdef TAU_MPC
#include <Profile/MPCThreadLayer.h>
#endif /* TAU_MPC */

/////////////////////////////////////////////////////////////////////////
// Member Function Definitions For class MPCThreadLayer
// This allows us to get thread ids from 0..N-1 instead of long nos 
// as generated by pthread_self() 
/////////////////////////////////////////////////////////////////////////
mpc_thread_mutex_t MPCThreadLayer::tauThreadCountMutex = MPC_THREAD_MUTEX_INITIALIZER;
mpc_thread_mutex_t MPCThreadLayer::tauDBMutex = MPC_THREAD_MUTEX_INITIALIZER;
mpc_thread_mutex_t MPCThreadLayer::tauEnvMutex = MPC_THREAD_MUTEX_INITIALIZER;



/////////////////////////////////////////////////////////////////////////
// Define the static private members of MPCThreadLayer  
/////////////////////////////////////////////////////////////////////////

int MPCThreadLayer::tauThreadCount = -1;

////////////////////////////////////////////////////////////////////////
// RegisterThread() should be called before any profiling routines are
// invoked. This routine sets the thread id that is used by the code in
// FunctionInfo and Profiler classes. This should be the first routine a 
// thread should invoke from its wrapper. Note: main() thread shouldn't
// call this routine. 
////////////////////////////////////////////////////////////////////////

int MPCThreadLayer::RegisterThread(void)
{
  mpc_thread_mutex_lock(&tauThreadCountMutex); 
  
  tauThreadCount ++;
  int *id = new int; 
  *id = tauThreadCount; 
  tls_args = (void *)id; 
  // A thread should call this routine exactly once. 
  //*threadId = RtsLayer::createThread();
  DEBUGPROFMSG("Thread id "<< *id << " Created! "<<endl;);
  mpc_thread_mutex_unlock(&tauThreadCountMutex); 

  return 0;

}


////////////////////////////////////////////////////////////////////////
// GetThreadId returns an id in the range 0..N-1 by looking at the 
// thread specific data. Since a getspecific has to be preceeded by a 
// setspecific (that all threads besides main do), we get a null for the
// main thread that lets us identify it as thread 0. It is the only 
// thread that doesn't do a MPCThreadLayer::RegisterThread(). 
////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::GetThreadId(void) {
  int tid = *(int *) tls_args; 
  TAU_VERBOSE("Inside GetThreadId: tid = %d\n", tid);
  return tid;
}


void MPCThreadLayer::SetThreadId(int tid) {
  //static 
  int *id = new int; 
  *id = tid; 
  tls_args = (void *) id; 
  return;
}


////////////////////////////////////////////////////////////////////////
// InitializeThreadData is called before any thread operations are performed. 
// It sets the default values for static private data members of the 
// MPCThreadLayer class.
////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::InitializeThreadData(void) {
  TAU_VERBOSE("MPCThreadLayer::InitializeThreadData\n");
  fflush(stdout);
  return 0;

}

////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::InitializeDBMutexData(void)
{
  // For locking functionDB 
  
  DEBUGPROFMSG(" Initialized the functionDB Mutex data " <<endl;);
  return 1;
}

////////////////////////////////////////////////////////////////////////
// LockDB locks the mutex protecting TheFunctionDB() global database of 
// functions. This is required to ensure that push_back() operation 
// performed on this is atomic (and in the case of tracing this is 
// followed by a GetFunctionID() ). This is used in 
// FunctionInfo::FunctionInfoInit().
////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::LockDB(void)
{
  TAU_VERBOSE("Before MPCThreadLayer::LockDB: %d\n", RtsLayer::myThread());
  mpc_thread_mutex_lock(&tauDBMutex);
  TAU_VERBOSE("MPCThreadLayer::LockDB\n");

  return 0;
}

////////////////////////////////////////////////////////////////////////
// UnLockDB() unlocks the mutex tauDBMutex used by the above lock operation
////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::UnLockDB(void)
{
  TAU_VERBOSE("Before MPCThreadLayer::UnLockDB: %d\n", RtsLayer::myThread());
  mpc_thread_mutex_unlock(&tauDBMutex);
  TAU_VERBOSE("MPCThreadLayer::UnLockDB\n");
  return 0;
}  


////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::InitializeEnvMutexData(void)
{
  TAU_VERBOSE("MPCThreadLayer::InitializeEnvMutexData\n");
  // For locking functionEnv 
  
  //cout <<" Initialized the functionEnv Mutex data " <<endl;
  return 1;
}

////////////////////////////////////////////////////////////////////////
// LockEnv locks the mutex protecting TheFunctionEnv() global database of 
// functions. This is required to ensure that push_back() operation 
// performed on this is atomic (and in the case of tracing this is 
// followed by a GetFunctionID() ). This is used in 
// FunctionInfo::FunctionInfoInit().
////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::LockEnv(void)
{
  int tid = RtsLayer::myThread(); 
  TAU_VERBOSE("Before MPCThreadLayer::LockEnv: %d\n", tid); 
  mpc_thread_mutex_lock(&tauEnvMutex);
  TAU_VERBOSE("MPCThreadLayer::LockEnv\n");
  return 0;
  static int initflag=InitializeEnvMutexData();
  // Lock the functionEnv mutex
  return 1;
}

////////////////////////////////////////////////////////////////////////
// UnLockEnv() unlocks the mutex tauEnvMutex used by the above lock operation
////////////////////////////////////////////////////////////////////////
int MPCThreadLayer::UnLockEnv(void)
{
  TAU_VERBOSE("Before MPCThreadLayer::UnLockEnv: %d\n", RtsLayer::myThread());
  mpc_thread_mutex_unlock(&tauEnvMutex);
  TAU_VERBOSE("MPCThreadLayer::UnLockEnv\n");
  return 0;
}  


extern "C" void MPC_Process_hook(void)
{
        int process;
        MPC_Process_rank(&process);
        TAU_VERBOSE("Starting process %d...\n", process); 
}

extern "C" void MPC_Task_hook( int rank )
{
        TAU_VERBOSE("Starting task %d...\n", rank);
        MPCThreadLayer::RegisterThread();
        TAU_VERBOSE("After registration of thread task %d...\n", rank);
} 



/***************************************************************************
 * $RCSfile: MPCThreadLayer.cpp,v $   $Author: amorris $
 * $Revision: 1.25 $   $Date: 2010/05/11 22:57:50 $
 * POOMA_VERSION_ID: $Id: MPCThreadLayer.cpp,v 1.25 2010/05/11 22:57:50 amorris Exp $
 ***************************************************************************/
